# Custom Operators & Automation

## Beyond Off-the-Shelf Solutions

While the homelab leverages many excellent open-source projects, some requirements demand **custom automation** tailored to specific needs:

1. **DerivedSecret Operator**: Deterministic secret generation from master password
2. **Metabase CNPG Operator**: Automatic database discovery and connection management
3. **Gitea Automation**: GitHub organization synchronization and token management

These operators showcase **Kubernetes custom controllers** and platform engineering patterns.

## Philosophy

### Why Build Custom Operators?

**When to use off-the-shelf**:
- ✅ Mature, well-maintained projects (cert-manager, ArgoCD, MetalLB)
- ✅ Widely-used patterns (ingress-nginx, external-dns)
- ✅ Complex implementations that would take months to build (Cilium, K3s)

**When to build custom**:
- ✅ Specific workflow not available elsewhere
- ✅ Learning opportunity for operator patterns
- ✅ Integration between multiple systems
- ✅ Simplicity over complexity for narrow use case

### Operator Patterns Used

**1. Shell-Operator** (DerivedSecrets):
- Bash hooks for CRD watching
- File-based IPC for simplicity
- Python handler for crypto operations

**2. Job-Based** (Metabase CNPG):
- Periodic sync via CronJob
- Watches CloudNativePG resources
- Updates Metabase via API

**3. Automation Scripts** (Gitea):
- One-time setup job
- Organization and repository management
- Token generation and webhook configuration

## DerivedSecret Operator

### Problem Statement

**Traditional secret management**:
- ❌ Random generation → not reproducible
- ❌ HashiCorp Vault → requires unsealing, external dependency
- ❌ Sealed Secrets → requires backup of sealing key
- ❌ Hardcoded secrets → not GitOps friendly

**Desired properties**:
- ✅ Deterministic: Same input = same output
- ✅ Cryptographically secure: Argon2id KDF
- ✅ GitOps friendly: Declarative CRD
- ✅ No external dependencies: Runs in-cluster
- ✅ Reproducible: Rebuild cluster from master password + CRDs

### Architecture

![DerivedSecret Architecture](./images/derivedsecret-architecture.png)
*Placeholder: Diagram showing Shell-operator → Bash hook → File IPC → Python handler → Argon2id → Kubernetes Secret*

**Components**:
1. **Shell-Operator**: Watches DerivedSecret CRDs (all namespaces)
2. **Bash Hook**: Writes binding context to `/shared/request-{id}.json`
3. **Python Handler**: Watches `/shared`, derives secrets, creates/updates Kubernetes Secrets
4. **File-Based IPC**: Simple, no sockets/HTTP, works with BusyBox/Alpine
5. **StatefulSet**: Persistent storage (200Mi PVC) for pip packages

### How It Works

**Derivation Formula**:
```
Argon2id(
  password = master_password,
  salt = "namespace:name:key_name",
  time_cost = 16,
  memory_cost = 65536,  # 64MB
  parallelism = 4,
  hash_len = 64
) → Base62 encode → truncate to desired length
```

**Example**:
```yaml
apiVersion: zengarden.space/v1
kind: DerivedSecret
metadata:
  name: gitea-admin
  namespace: gitea
spec:
  username: 16
  password: 32
```

**Derivation Context**:
- `username`: `gitea:gitea-admin:username` → 16-char Base62 string
- `password`: `gitea:gitea-admin:password` → 32-char Base62 string

**Result** (Kubernetes Secret):
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: gitea-admin
  namespace: gitea
type: Opaque
data:
  username: <base64-encoded derived username>
  password: <base64-encoded derived password>
```

### Entropy Analysis

**Base62 Alphabet**: `A-Za-z0-9` (62 characters)
- **Bits per character**: log₂(62) ≈ 5.95 bits

**Entropy Requirements**:

| Use Case | Min Bits | Min Length | Recommended |
|----------|----------|------------|-------------|
| Database password | 128 | 22 chars | 32 chars |
| JWT secret | 256 | 43 chars | 64 chars |
| API key | 256 | 43 chars | 64 chars |
| Admin credentials | 128 | 22 chars | 32 chars |

### Implementation Details

**Python Handler** (`helmfile/secrets-system/derived-secret-operator/files/crypto-service.py`):
```python
import argon2
import base64

def derive_secret(master_password, namespace, name, key_name, length):
    """Derive deterministic secret using Argon2id"""
    salt = f"{namespace}:{name}:{key_name}".encode('utf-8')

    # Argon2id parameters
    hasher = argon2.PasswordHasher(
        time_cost=16,
        memory_cost=65536,  # 64MB
        parallelism=4,
        hash_len=64,
        type=argon2.Type.ID
    )

    # Derive secret
    derived = hasher.hash(master_password, salt=salt)

    # Base62 encode
    base62_chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    result = ""
    for byte in derived:
        result += base62_chars[byte % 62]

    return result[:length]
```

**Bash Hook** (`helmfile/secrets-system/derived-secret-operator/files/derived-secret-handler.sh`):
```bash
#!/bin/bash
set -euo pipefail

# Write binding context to /shared
request_id=$(uuidgen)
echo "$BINDING_CONTEXT" > "/shared/request-${request_id}.json"

# Wait for Python handler to process
while [ ! -f "/shared/response-${request_id}.txt" ]; do
  sleep 0.1
done

# Read response and cleanup
cat "/shared/response-${request_id}.txt"
rm -f "/shared/request-${request_id}.json" "/shared/response-${request_id}.txt"
```

### Merge Strategy

**Intelligent secret merging**:
- Existing secret has: `username`, `password`, `manualKey`
- DerivedSecret specifies: `password`, `apiKey`
- Result: `username` (preserved), `password` (overridden), `manualKey` (preserved), `apiKey` (added)

**Why important**: Allows manual keys alongside derived ones without conflicts.

### Usage Examples

**1. Gitea Admin Credentials**:
```yaml
apiVersion: zengarden.space/v1
kind: DerivedSecret
metadata:
  name: gitea-admin
  namespace: gitea
spec:
  username: 16
  password: 32
  adminToken: 64
```

**2. Database Passwords**:
```yaml
apiVersion: zengarden.space/v1
kind: DerivedSecret
metadata:
  name: app-db
  namespace: production
spec:
  DATABASE_PASSWORD: 32
  POSTGRES_PASSWORD: 32
  MYSQL_ROOT_PASSWORD: 32
```

**3. API Keys**:
```yaml
apiVersion: zengarden.space/v1
kind: DerivedSecret
metadata:
  name: external-apis
  namespace: production
spec:
  GITHUB_TOKEN: 64
  CLOUDFLARE_API_KEY: 64
  SLACK_WEBHOOK_SECRET: 64
```

### Security Considerations

**Strengths**:
- ✅ Argon2id: Memory-hard, resistant to GPU/ASIC attacks
- ✅ Deterministic: No random number generator concerns
- ✅ Unique salts: Namespace + name + key ensures uniqueness
- ✅ Master password not in cluster: Only in bootstrap env.yaml

**Weaknesses**:
- ❌ Master password compromise = all secrets compromised
- ❌ No automatic rotation (manual master password change)
- ❌ Not suitable for secrets requiring external validation (API tokens)

**Mitigation**:
- Store master password in password manager
- Use different master password per environment
- Combine with External Secrets Operator for external APIs

## Metabase CNPG Operator

### Problem Statement

**Manual database management in Metabase**:
- ❌ Every new PostgreSQL database requires manual Metabase configuration
- ❌ Connection details change when databases move
- ❌ Credentials rotation requires UI clicks

**Desired automation**:
- ✅ Detect new CloudNativePG (CNPG) databases automatically
- ✅ Create Metabase database connections
- ✅ Update credentials automatically
- ✅ Remove connections when database deleted

### Architecture

**Components**:
1. **CronJob**: Runs every 5 minutes
2. **Kubernetes Watch**: Monitors CNPG `Database` and `Cluster` resources
3. **Secret Resolution**: Reads connection credentials from Kubernetes Secrets
4. **Metabase API**: Creates/updates database connections

### How It Works

**1. Discover CNPG Databases**:
```bash
kubectl get databases.postgresql.cnpg.io -A -o json
```

**2. Extract Connection Info**:
```yaml
apiVersion: postgresql.cnpg.io/v1
kind: Database
metadata:
  name: gitea
  namespace: gitea
spec:
  cluster:
    name: gitea-cluster  # References CNPG Cluster
  owner: gitea
```

**3. Get Cluster Details**:
```bash
kubectl get cluster gitea-cluster -n gitea -o json
# Extract: host, port, superuser secret reference
```

**4. Read Credentials**:
```bash
kubectl get secret gitea-cluster-superuser -n gitea -o json
# Extract: username, password
```

**5. Create/Update Metabase Connection**:
```bash
curl -X POST https://metabase.homelab.int.zengarden.space/api/database \
  -H "X-Metabase-Session: $SESSION_TOKEN" \
  -d '{
    "engine": "postgres",
    "name": "gitea",
    "details": {
      "host": "gitea-cluster-rw.gitea.svc.cluster.local",
      "port": 5432,
      "dbname": "gitea",
      "user": "postgres",
      "password": "...",
      "ssl": true
    }
  }'
```

### Benefits

**Before automation**:
1. Deploy PostgreSQL via CNPG
2. SSH to Metabase pod to get connection string
3. Open Metabase UI
4. Click "Add Database"
5. Fill in host, port, database, username, password
6. Test connection
7. Save

**After automation**:
1. Deploy PostgreSQL via CNPG
2. **Metabase connection appears automatically in 5 minutes**

**Result**: ~10 minutes saved per database, zero manual errors

### Implementation

**CronJob** (`helmfile/metabase/charts/metabase-cnpg-operator/templates/cronjob.yaml`):
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: metabase-cnpg-sync
spec:
  schedule: "*/5 * * * *"  # Every 5 minutes
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: metabase-cnpg-operator
          containers:
          - name: sync
            image: alpine/curl:latest
            command: ["/bin/sh", "/scripts/sync.sh"]
            volumeMounts:
            - name: scripts
              mountPath: /scripts
```

**Sync Script** (simplified):
```bash
#!/bin/sh
set -eu

# Login to Metabase
SESSION=$(curl -X POST "$METABASE_URL/api/session" \
  -d "{\"username\": \"$MB_ADMIN_EMAIL\", \"password\": \"$MB_ADMIN_PASSWORD\"}" \
  | jq -r '.id')

# Get all CNPG databases
kubectl get databases.postgresql.cnpg.io -A -o json | jq -r '.items[] |
  @json' | while read db_json; do

  namespace=$(echo "$db_json" | jq -r '.metadata.namespace')
  name=$(echo "$db_json" | jq -r '.metadata.name')
  cluster=$(echo "$db_json" | jq -r '.spec.cluster.name')

  # Get cluster connection info
  host="${cluster}-rw.${namespace}.svc.cluster.local"

  # Get credentials from secret
  secret_name="${cluster}-superuser"
  username=$(kubectl get secret "$secret_name" -n "$namespace" \
    -o jsonpath='{.data.username}' | base64 -d)
  password=$(kubectl get secret "$secret_name" -n "$namespace" \
    -o jsonpath='{.data.password}' | base64 -d)

  # Check if database exists in Metabase
  existing=$(curl -s "$METABASE_URL/api/database" \
    -H "X-Metabase-Session: $SESSION" \
    | jq -r ".data[] | select(.name == \"$name\") | .id")

  if [ -z "$existing" ]; then
    # Create new connection
    curl -X POST "$METABASE_URL/api/database" \
      -H "X-Metabase-Session: $SESSION" \
      -d "{
        \"engine\": \"postgres\",
        \"name\": \"$name\",
        \"details\": {
          \"host\": \"$host\",
          \"port\": 5432,
          \"dbname\": \"$name\",
          \"user\": \"$username\",
          \"password\": \"$password\",
          \"ssl\": true
        }
      }"
  else
    # Update existing connection
    curl -X PUT "$METABASE_URL/api/database/$existing" \
      -H "X-Metabase-Session: $SESSION" \
      -d "{
        \"details\": {
          \"password\": \"$password\"
        }
      }"
  fi
done
```

## Gitea Automation

### Problem Statement

**Manual Gitea setup**:
- ❌ Create organization manually
- ❌ Clone repositories from GitHub one by one
- ❌ Generate personal access tokens via UI
- ❌ Configure webhooks for each repository

**Desired automation**:
- ✅ Organization created automatically
- ✅ Repositories synced from GitHub
- ✅ Tokens generated with correct scopes
- ✅ Webhooks configured for ArgoCD

### How It Works

**Job Flow**:
1. **Organization Creation**: Creates `zengarden-space` if not exists
2. **Repository Sync**: Lists GitHub org repos, clones to Gitea
3. **Token Generation**: Creates PATs for automation, package writing, content writing
4. **Webhook Setup**: Configures push event webhooks to ArgoCD

**Smart Token Management**:
- Only regenerates if scopes change
- Stores token in Kubernetes Secret
- Validates token before creating new one

### Implementation

**Job** (`helmfile/gitea/charts/gitea-automation/templates/sync-job.yaml`):
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: gitea-automation-sync
spec:
  template:
    spec:
      containers:
      - name: sync
        image: alpine/curl:8.14.1
        command: ["/bin/sh", "/scripts/sync.sh"]
        env:
        - name: GITHUB_TOKEN
          valueFrom:
            secretKeyRef:
              name: gitea-automation
              key: github-token
        - name: GITEA_ADMIN_PASSWORD
          valueFrom:
            secretKeyRef:
              name: gitea-admin
              key: password
```

## Summary

Custom operators provide:

1. **DerivedSecrets**: Deterministic, reproducible secret management
2. **Metabase CNPG**: Automatic database connection discovery
3. **Gitea Automation**: Zero-touch repository synchronization

These demonstrate **Kubernetes operator patterns** and show when to build custom vs. use off-the-shelf solutions.
