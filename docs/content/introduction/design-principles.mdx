# Design Principles

## Core Tenets

This homelab is built on several fundamental principles that guide every architectural decision:

## 1. Infrastructure as Code

**Principle**: Every component must be declaratively defined in version-controlled code.

### Implementation
- **Ansible** for bare metal provisioning
- **Helmfile** for Kubernetes infrastructure
- **ArgoCD** for application delivery
- **Git** as the source of truth

### Benefits
- **Reproducibility**: Rebuild entire cluster from code
- **Auditability**: Track all changes through Git history
- **Documentation**: Code serves as authoritative reference
- **Collaboration**: Review infrastructure changes like application code

### Example
```yaml
# helmfile/metallb-system/helmfile.yaml.gotmpl
releases:
  - name: metallb
    namespace: metallb-system
    chart: metallb/metallb
    version: 0.14.5
    values:
      - controller:
          enabled: true
```

No manual kubectl commands, no ClickOps—everything through declarative manifests.

## 2. GitOps First

**Principle**: All changes flow through Git with automated deployment pipelines.

### Workflow
```
Developer commits → GitHub
  ↓
Gitea automation syncs
  ↓
Gitea Actions build & push
  ↓
Manifests repository updated
  ↓
ArgoCD detects change
  ↓
Automatic deployment
```

### Benefits
- **Single source of truth**: Git repository
- **Automated deployments**: No manual kubectl apply
- **Rollback capability**: Git revert to previous state
- **Audit trail**: Complete history of who changed what

## 3. Security by Default

**Principle**: Security is not an afterthought—it's built into every layer.

### Defense in Depth

**Layer 1: Network Segmentation**
- VLAN isolation (homelab, home, IoT, management)
- Firewall rules between networks
- VPN for external access only

**Layer 2: Kubernetes Hardening**
- Pod Security Admissions (restricted mode)
- RBAC with least privilege
- Network policies via Cilium
- Audit logging enabled

**Layer 3: Application Security**
- Non-root containers
- Dropped capabilities
- Read-only root filesystems
- seccompProfile: RuntimeDefault

**Layer 4: Secret Management**
- Secrets never in Git (env.yaml gitignored)
- DerivedSecrets with Argon2id KDF
- Secret encryption at rest
- Automatic rotation capabilities

### Example: K3s Security Hardening
```yaml
# ansible/install-k3s/files/k3s-server.yaml
kube-apiserver-arg:
  - "admission-control-config-file=/var/lib/rancher/k3s/server/psa.yaml"
  - "audit-log-path=/var/lib/rancher/k3s/server/logs/audit.log"
  - "audit-log-maxage=30"
  - "enable-admission-plugins=NodeRestriction,EventRateLimit"
  - "encryption-provider-config=/var/lib/rancher/k3s/server/encryption.yaml"
```

## 4. Deterministic Operations

**Principle**: Same inputs always produce same outputs—no manual steps, no randomness.

### Implementation

**DerivedSecrets Operator**:
- Master password + context → deterministic secrets
- Same inputs always generate same passwords
- Argon2id ensures cryptographic strength
- No random generation = reproducible deployments

**Helmfile Dependencies**:
- Explicit ordering of component deployment
- Deterministic chart versions (no "latest")
- Reproducible environment from env.yaml

### Example
```yaml
apiVersion: secrets.homelab.int.zengarden.space/v1
kind: DerivedSecret
metadata:
  name: gitea-admin
spec:
  masterPasswordRef:
    name: master-password
    key: password
  secrets:
    - key: username
      length: 16
      context: "gitea-admin-username"
    - key: password
      length: 32
      context: "gitea-admin-password"
```
Same master password + context = same credentials every time.

## 5. Observable Systems

**Principle**: Comprehensive visibility into system behavior through metrics, logs, and traces.

### Observability Stack
- **Metrics**: Victoria Metrics (Prometheus-compatible)
- **Logs**: K3s audit logs, container logs
- **Alerts**: AlertManager + Gotify notifications
- **Dashboards**: Grafana for visualization

### Key Metrics Tracked
- Node resource utilization (CPU, memory, disk)
- Pod restart counts and crash loops
- API server request latencies
- Certificate expiration times
- DNS query performance
- Ingress traffic patterns

## 6. Kubernetes-First

**Principle**: Run everything possible in Kubernetes for consistency and automation.

### What Runs in Kubernetes
- Load balancing (MetalLB)
- Certificate management (cert-manager)
- DNS synchronization (external-dns)
- Git server (Gitea)
- CI/CD (Gitea Actions)
- Database (CloudNativePG)
- Metrics (Victoria Metrics)
- GitOps (ArgoCD)

### What Runs Outside (Inevitable Exceptions)
- **K3s itself**: Can't bootstrap Kubernetes from within Kubernetes
- **NVMe partitioning**: Bare metal storage setup
- **Restrictive proxy**: Security boundary before cluster access

### Justification for Exceptions
Each exception documented with:
- Why Kubernetes can't handle it
- What alternatives were considered
- How it integrates with the cluster

## 7. Minimal Manual Intervention

**Principle**: Automation over manual processes—reduce toil and human error.

### Automated Processes

**Gitea Automation**:
- Organization creation
- Repository synchronization from GitHub
- Personal access token generation
- Webhook configuration

**Certificate Management**:
- Automatic Let's Encrypt certificate issuance
- Renewal before expiration
- Internal CA rotation via CronJob

**Database Management**:
- Metabase database auto-discovery from CNPG resources
- Connection credential updates
- Health monitoring

**DNS Synchronization**:
- Ingress annotations → MikroTik DNS records
- Automatic cleanup when ingress deleted
- Cloudflare for external domains

## 8. Energy Efficiency

**Principle**: Minimize power consumption while maintaining capability.

### Hardware Choices
- **ARM64 over x86**: CM5 uses ~2-5W per node vs ~50W for typical x86
- **NVMe over SATA**: Lower power than 2.5" SSDs with spinning disks
- **PoE power delivery**: Efficient centralized power supply
- **No active cooling**: Fanless operation reduces noise and power

### Outcome
- **Total cluster**: 28-40W under load
- **Per node**: 4-8W average
- **Cost**: ~$4/month in electricity
- **Heat**: Minimal—no dedicated cooling needed

## 9. Simplicity Over Complexity

**Principle**: Choose simple solutions over complex ones when they meet requirements.

### Examples

**K3s over vanilla Kubernetes**:
- Single binary vs multi-component installation
- Built-in SQLite option (though we use etcd for HA)
- Automatic TLS certificate management
- Lower memory footprint

**Helmfile over Terraform/Pulumi for Kubernetes**:
- Native Helm integration
- Simpler YAML vs programming language
- Easier to audit and review
- Familiar to Kubernetes operators

**File-based IPC in DerivedSecrets**:
- Simpler than HTTP server + client
- No port conflicts or TLS setup
- Easy to debug (inspect files)
- Sufficient for operator use case

## 10. Documentation as Code

**Principle**: Documentation is part of the codebase, maintained alongside infrastructure.

### Documentation Strategy
- **README files** in each Ansible playbook directory
- **Inline comments** in complex configurations
- **This Nextra site** for comprehensive guides
- **Architecture diagrams** as code (PlantUML, Mermaid)

### Living Documentation
- Updated when infrastructure changes
- Reviewed during pull requests
- Versioned alongside code
- Generated examples from real configs

## Decision Framework

When making architectural choices, evaluate against these criteria:

### 1. Does it align with GitOps?
- Can it be declaratively defined in Git?
- Can changes be automatically deployed?
- Is there an audit trail?

### 2. Does it improve security?
- Does it reduce attack surface?
- Does it implement least privilege?
- Does it enable better monitoring?

### 3. Is it deterministic?
- Same inputs → same outputs?
- Can it be reliably reproduced?
- Are dependencies explicitly versioned?

### 4. Is it observable?
- Can we monitor its health?
- Are logs accessible?
- Can we alert on failures?

### 5. Is it cost-effective?
- Power consumption impact?
- Maintenance overhead?
- Learning value vs complexity?

## Anti-Patterns Avoided

### ❌ Manual Configuration
- No SSH-ing into nodes to edit configs
- No kubectl edit in production
- No ClickOps in UIs

### ❌ Implicit Dependencies
- All component dependencies explicitly declared
- Helmfile manages deployment order
- No "run this after that" documentation

### ❌ Secrets in Git
- All env.yaml files gitignored
- Secrets derived or externally referenced
- No hardcoded passwords

### ❌ Single Points of Failure
- Multi-master K3s for control plane HA
- Distributed etcd across masters
- Load balancing for ingress

### ❌ Vendor Lock-In
- Cloud-agnostic Kubernetes
- Standard APIs (Ingress, Service, etc.)
- Portable Helm charts

## Conclusion

These principles create a homelab that is:
- **Reproducible**: Rebuild from code
- **Secure**: Defense in depth
- **Observable**: Comprehensive monitoring
- **Automated**: Minimal manual intervention
- **Educational**: Clear patterns to learn from

Every technical decision in subsequent sections traces back to these foundational principles.
